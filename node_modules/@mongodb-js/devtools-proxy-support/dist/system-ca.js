"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resetSystemCACache = resetSystemCACache;
exports.mergeCA = mergeCA;
exports.parseCACerts = parseCACerts;
exports.removeCertificatesWithoutIssuer = removeCertificatesWithoutIssuer;
exports.sortByExpirationDate = sortByExpirationDate;
exports.tlsSupportsAllowPartialTrustChainFlag = tlsSupportsAllowPartialTrustChainFlag;
exports.systemCA = systemCA;
const system_ca_1 = require("system-ca");
const fs_1 = require("fs");
const tls_1 = require("tls");
const crypto_1 = require("crypto");
let systemCertsCachePromise;
function resetSystemCACache(systemCAOpts = {}) {
    systemCertsCachePromise = undefined;
    systemCertsCached(systemCAOpts).catch(() => undefined);
}
function systemCertsCached(systemCAOpts = {}) {
    if (systemCertsCachePromise)
        return systemCertsCachePromise;
    systemCertsCachePromise = (async () => {
        const certs = await (0, system_ca_1.systemCertsAsync)(systemCAOpts);
        return { certs, asyncFallbackError: systemCAOpts.asyncFallbackError };
    })();
    systemCertsCachePromise.catch(() => {
    });
    return systemCertsCachePromise;
}
function certToString(cert) {
    return typeof cert === 'string'
        ? cert
        : Buffer.from(cert.buffer, cert.byteOffset, cert.byteLength).toString('utf8');
}
function mergeCA(...args) {
    const ca = new Set();
    for (const item of args) {
        if (!item)
            continue;
        const caList = Array.isArray(item) ? item : [item];
        for (const cert of caList) {
            ca.add(certToString(cert));
        }
    }
    return [...ca].join('\n');
}
function parseCACerts(ca, messages) {
    ca = Array.isArray(ca) ? ca : [ca];
    return ca.map((cert) => {
        const pem = certToString(cert);
        let parsed = null;
        try {
            parsed = new crypto_1.X509Certificate(pem);
        }
        catch (err) {
            messages.push(`Unable to parse certificate: ${err && typeof err === 'object' && 'message' in err
                ? String(err.message)
                : String(err)}`);
        }
        return { pem, parsed };
    });
}
function certificateHasMatchingIssuer(cert, certs) {
    return (cert.checkIssued(cert) ||
        certs.some(({ parsed: issuer }) => {
            return issuer && cert.checkIssued(issuer);
        }));
}
const withRemovedMissingIssuerCache = new WeakMap();
function removeCertificatesWithoutIssuer(ca, messages) {
    const result = withRemovedMissingIssuerCache.get(ca);
    if (result) {
        messages.push(...result.messages);
        return result.ca;
    }
    const _messages = [];
    const filteredCAlist = ca.filter((cert) => {
        const keep = !cert.parsed || certificateHasMatchingIssuer(cert.parsed, ca);
        if (!keep && cert.parsed) {
            const { parsed } = cert;
            _messages.push(`Removing certificate for '${parsed.subject}' because issuer '${parsed.issuer}' could not be found (serial no '${parsed.serialNumber}')`);
        }
        return keep;
    });
    withRemovedMissingIssuerCache.set(ca, {
        ca: filteredCAlist,
        messages: _messages,
    });
    messages.push(..._messages);
    return filteredCAlist;
}
function sortByExpirationDate(ca) {
    return ca.slice().sort((a, b) => {
        if (!a.parsed || !b.parsed) {
            return 0;
        }
        return (new Date(b.parsed.validTo).getTime() -
            new Date(a.parsed.validTo).getTime());
    });
}
const nodeVersion = process.versions.node.split('.').map(Number);
function tlsSupportsAllowPartialTrustChainFlag() {
    return ((nodeVersion[0] >= 22 && nodeVersion[1] >= 9) ||
        (nodeVersion[0] === 20 && nodeVersion[1] >= 18));
}
async function systemCA(existingOptions = {}, allowCertificatesWithoutIssuer) {
    let readTLSCAFilePromise;
    if (existingOptions.tlsCAFile) {
        readTLSCAFilePromise = fs_1.promises.readFile(existingOptions.tlsCAFile, 'utf8');
        readTLSCAFilePromise.catch(() => {
        });
    }
    let systemCertsError;
    let asyncFallbackError;
    let systemCerts = [];
    const messages = [];
    const _tlsSupportsAllowPartialTrustChainFlag = tlsSupportsAllowPartialTrustChainFlag();
    try {
        const systemCertsResult = await systemCertsCached();
        asyncFallbackError = systemCertsResult.asyncFallbackError;
        if (_tlsSupportsAllowPartialTrustChainFlag) {
            systemCerts = systemCertsResult.certs.map((pem) => ({
                pem,
                parsed: null,
            }));
        }
        else {
            systemCerts = parseCACerts(systemCertsResult.certs, messages);
        }
    }
    catch (err) {
        systemCertsError = err;
    }
    if (!(allowCertificatesWithoutIssuer ??
        !!process.env.DEVTOOLS_ALLOW_CERTIFICATES_WITHOUT_ISSUER) &&
        !_tlsSupportsAllowPartialTrustChainFlag) {
        systemCerts = removeCertificatesWithoutIssuer(systemCerts, messages);
    }
    return {
        ca: mergeCA((_tlsSupportsAllowPartialTrustChainFlag
            ? systemCerts
            : sortByExpirationDate(systemCerts)).map(({ pem }) => pem), tls_1.rootCertificates, existingOptions.ca, await readTLSCAFilePromise),
        asyncFallbackError: asyncFallbackError,
        systemCertsError,
        systemCACount: systemCerts.length + tls_1.rootCertificates.length,
        messages,
    };
}
//# sourceMappingURL=system-ca.js.map